class Matrix { constructor(c, d) { this.rows = c, this.cols = d, this.data = Array(this.rows).fill().map(() => Array(this.cols).fill(0)) } copy() { let c = new Matrix(this.rows, this.cols); for (let d = 0; d < this.rows; d++)for (let f = 0; f < this.cols; f++)c.data[d][f] = this.data[d][f]; return c } static fromArray(c) { return new Matrix(c.length, 1).map((d, f) => c[f]) } static subtract(c, d) { return c.rows !== d.rows || c.cols !== d.cols ? void console.log('Columns and Rows of A must match Columns and Rows of B.') : new Matrix(c.rows, c.cols).map((f, g, h) => c.data[g][h] - d.data[g][h]) } toArray() { let c = []; for (let d = 0; d < this.rows; d++)for (let f = 0; f < this.cols; f++)c.push(this.data[d][f]); return c } randomize() { return this.map(() => 2 * Math.random() - 1) } add(c) { return c instanceof Matrix ? this.rows !== c.rows || this.cols !== c.cols ? void console.log('Columns and Rows of A must match Columns and Rows of B.') : this.map((d, f, g) => d + c.data[f][g]) : this.map(d => d + c) } static transpose(c) { return new Matrix(c.cols, c.rows).map((d, f, g) => c.data[g][f]) } static multiply(c, d) { return c.cols === d.rows ? new Matrix(c.rows, d.cols).map((f, g, h) => { let l = 0; for (let o = 0; o < c.cols; o++)l += c.data[g][o] * d.data[o][h]; return l }) : void console.log('Columns of A must match rows of B.') } multiply(c) { return c instanceof Matrix ? this.rows !== c.rows || this.cols !== c.cols ? void console.log('Columns and Rows of A must match Columns and Rows of B.') : this.map((d, f, g) => d * c.data[f][g]) : this.map(d => d * c) } map(c) { for (let d = 0; d < this.rows; d++)for (let g, f = 0; f < this.cols; f++)g = this.data[d][f], this.data[d][f] = c(g, d, f); return this } static map(c, d) { return new Matrix(c.rows, c.cols).map((f, g, h) => d(c.data[g][h], g, h)) } print() { return console.table(this.data), this } serialize() { return JSON.stringify(this) } static deserialize(c) { 'string' == typeof c && (c = JSON.parse(c)); let d = new Matrix(c.rows, c.cols); return d.data = c.data, d } } 'undefined' != typeof module && (module.exports = Matrix); class ActivationFunction { constructor(d, e) { this.func = d, this.dfunc = e } } let sigmoid = new ActivationFunction(d => 1 / (1 + Math.exp(-d)), d => d * (1 - d)), tanh = new ActivationFunction(d => Math.tanh(d), d => 1 - d * d); class NeuralNetwork { constructor(d, e, f) { d instanceof NeuralNetwork ? (this.input_nodes = d.input_nodes, this.hidden_nodes = d.hidden_nodes, this.output_nodes = d.output_nodes, this.weights_ih = d.weights_ih.copy(), this.weights_ho = d.weights_ho.copy(), this.bias_h = d.bias_h.copy(), this.bias_o = d.bias_o.copy()) : (this.input_nodes = d, this.hidden_nodes = e, this.output_nodes = f, this.weights_ih = new Matrix(this.hidden_nodes, this.input_nodes), this.weights_ho = new Matrix(this.output_nodes, this.hidden_nodes), this.weights_ih.randomize(), this.weights_ho.randomize(), this.bias_h = new Matrix(this.hidden_nodes, 1), this.bias_o = new Matrix(this.output_nodes, 1), this.bias_h.randomize(), this.bias_o.randomize()), this.setLearningRate(), this.setActivationFunction() } predict(d) { let e = Matrix.fromArray(d), f = Matrix.multiply(this.weights_ih, e); f.add(this.bias_h), f.map(this.activation_function.func); let g = Matrix.multiply(this.weights_ho, f); return g.add(this.bias_o), g.map(this.activation_function.func), g.toArray() } setLearningRate(d = 0.1) { this.learning_rate = d } setActivationFunction(d = sigmoid) { this.activation_function = d } train(d, e) { let f = Matrix.fromArray(d), g = Matrix.multiply(this.weights_ih, f); g.add(this.bias_h), g.map(this.activation_function.func); let h = Matrix.multiply(this.weights_ho, g); h.add(this.bias_o), h.map(this.activation_function.func); let i = Matrix.fromArray(e), j = Matrix.subtract(i, h), k = Matrix.map(h, this.activation_function.dfunc); k.multiply(j), k.multiply(this.learning_rate); let l = Matrix.transpose(g), m = Matrix.multiply(k, l); this.weights_ho.add(m), this.bias_o.add(k); let n = Matrix.transpose(this.weights_ho), o = Matrix.multiply(n, j), p = Matrix.map(g, this.activation_function.dfunc); p.multiply(o), p.multiply(this.learning_rate); let q = Matrix.transpose(f), r = Matrix.multiply(p, q); this.weights_ih.add(r), this.bias_h.add(p) } serialize() { return JSON.stringify(this) } static deserialize(d) { 'string' == typeof d && (d = JSON.parse(d)); let e = new NeuralNetwork(d.input_nodes, d.hidden_nodes, d.output_nodes); return e.weights_ih = Matrix.deserialize(d.weights_ih), e.weights_ho = Matrix.deserialize(d.weights_ho), e.bias_h = Matrix.deserialize(d.bias_h), e.bias_o = Matrix.deserialize(d.bias_o), e.learning_rate = d.learning_rate, e } copy() { return new NeuralNetwork(this) } mutate(d) { function e(f) { return Math.random() < d ? 1e3 * Math.random() - 1 : f } this.weights_ih.map(e), this.weights_ho.map(e), this.bias_h.map(e), this.bias_o.map(e) } }